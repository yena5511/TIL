## Singleton 패턴

- 프로세스에 특정 객체가 하나만 존재해야 할 때 쓰는 패턴
- 화면들에 공유되는 앱 세팅을 싱글턴으로 설정

- 자바에서 라이브러리나 프레임퉈크 없이 가장 안전하게 싱글톤을 생성할 수 있는 방법 중의 하나는 inner static class singleton이다

```java
package singleton.after;

public class Settings {

  private boolean darkMode = false;
  private int fontSize = 13;

  public boolean getDarkMode () { return darkMode; }
  public int getFontSize () { return fontSize; }

  public void setDarkMode (boolean _darkMode) { 
    darkMode = _darkMode; }
  public void setFontSize (int _fontSize) { 
    fontSize = _fontSize; }
}
```
- settings 란 클래스에서 다크모드 여부와 폰트 사이즈를 설정허고 접근 

```java
package singleton.after;

public class FirstPage {
  private Settings settings = Settings.getSettings();

  public void setAndPrintSettings () {
    settings.setDarkMode(true);
    settings.setFontSize(15);
    System.out.println(settings.getDarkMode() + " " + settings.getFontSize());
  }
}
```

```java
package singleton.after;

public class SecondPage {
  private Settings settings = Settings.getSettings();

  public void printSettings () {
    System.out.println(settings.getDarkMode() + " " + settings.getFontSize());
  }
}
```
- 페이지마다 다른 클래스를 만든다
- firstPage에서 settings 겍체의 설정들을 변경하고 그 내용을 출력
- secondPage에도 setting을 출력하는 함수를 만들고 메인에서 차례로 실행<br>
-> firstPage에서 변경한 내용들이 secondPage에는 적용되지 않음

*settings 클래스 변경*
```java
package singleton.after;

public class Settings {

  private Settings () {};
  private static Settings settings = null;

  public static Settings getSettings () {
    if (settings == null) {
      settings = new Settings();
    }
    return settings;
  }

  private boolean darkMode = false;
  private int fontSize = 13;

  public boolean getDarkMode () { return darkMode; }
  public int getFontSize () { return fontSize; }

  public void setDarkMode (boolean _darkMode) { 
    darkMode = _darkMode; }
  public void setFontSize (int _fontSize) { 
    fontSize = _fontSize; }
}
```

- static이 아닌 변수나 메소드들은 객체가 생성될 때마다 메모리의 공간을 새로 처지
- static으로 선언될 것들은 객체가 얼마나 만들어지든 메모리에 지정된 공간을 딱 하나씩만 존재

- 이 방법을 사용하면 멀티쓰레드에 안전하고, Lazy loading을 지원하며, serialization에도 안전한 싱글톤을 만들 수 있다

## Strategy 패턴

- 선택된 모두에 따라서, 검색 버튼을 눌렀을 때 실행되는 검색의 방식이 결정되도록 하는 코드
- 전략 패턴은 모드마다의 동작 하나하나를 모듈로 따로 분리해서, 버튼을 누를때마다 실행될 검색 모듈을 갈아끼워주는 방식의 코드

- 인터페이스는 그 자체로 객체를 만들 수 없지만 특정 인터페이스를 implement 한 클래스는 해당 인터페이스에서 지정한 메소드를 필수적으로 선언하고 장착해야 됨

```java
package strategy.after;

interface SearchStrategy {
  public void search ();
}

class SearchStratagyAll implements SearchStrategy {
  public void search () {
      System.out.println("SEARCH ALL");
      // 전체검색하는 코드
  }
}

class SearchStratagyImage implements SearchStrategy {
  public void search () {
      System.out.println("SEARCH IMAGE");
      // 이미지검색하는 코드
  }
}

class SearchStratagyNews implements SearchStrategy {
  public void search () {
      System.out.println("SEARCH NEWS");
      // 뉴스검색하는 코드
  }
}

class SearchStratagyMap implements SearchStrategy {
  public void search () {
      System.out.println("SEARCH MAP");
      // 지도검색하는 코드
  }
}
```

```java
package strategy.after;

public class SearchButton {

  private MyProgram myProgram;

  public SearchButton (MyProgram _myProgram) {
    myProgram = _myProgram;
  }

  private SearchStrategy searchStrategy = new SearchStratagyAll();
  
  public void setSearchStrategy (SearchStrategy _searchStrategy) {
    searchStrategy = _searchStrategy;
  }

  public void onClick () {
    searchStrategy.search();
  }
}
```
- search란 메소드를 갖기 때문에 SearchStrategy를 implement한 클래스들릉 모두 search라는 메소드르 갖고 있음

- 옵션들마다의 행동들을 모듈화해서 독립적이고 상호 교체 가능하게 만드는 것이 전력 패텬

## State 패턴

- 전략 패턴과 비슷 
- 전략 패턴은 어떤 동일한 틀 안에 있는 특정 적업의 방식, 모드를 바꿔줄 때
- state 패턴은 특정 상태마다 다르게 할 일을 나아가서 그 상태들 자체를 그 상태마다 실행시 할 일과 함께 하나하나 모듈화해서 지정해둘 때 쓰임

- 앱 화면의 다크모드 여부를 켰다 꼈다 하는 스위치를 프로그래밍한 예제

```java
package state;

public interface ModeState {
  public void toggle (ModeSwitch modeSwitch);
}

class ModeStateLight implements ModeState {
  public void toggle (ModeSwitch modeSwitch) {
    System.out.println("FROM LIGHT TO DARK");
    // 화면을 어둡게 하는 코드
    // ..
    // ..
    modeSwitch.setState(new ModeStateDark());
  }
}

class ModeStateDark implements ModeState {
  public void toggle (ModeSwitch modeSwitch) {
    System.out.println("FROM DARK TO LIGHT");
    // 화면을 밝게 하는 코드
    // ..
    // ..
    modeSwitch.setState(new ModeStateLight());

  }
}
```

```java
package state;

public interface ModeState {
  public void toggle (ModeSwitch modeSwitch);
}

class ModeStateLight implements ModeState {
  public void toggle (ModeSwitch modeSwitch) {
    System.out.println("FROM LIGHT TO DARK");
    // 화면을 어둡게 하는 코드
    // ..
    // ..
    modeSwitch.setState(new ModeStateDark());
  }
}

class ModeStateDark implements ModeState {
  public void toggle (ModeSwitch modeSwitch) {
    System.out.println("FROM DARK TO LIGHT");
    // 화면을 밝게 하는 코드
    // ..
    // ..
    modeSwitch.setState(new ModeStateLight());

  }
}
```
- 모드의 상태를 나타내는 인터페이스 
- 라이트 모드에서 스위치를 가동하면 다크모드로 다크모드에서는 라이크 모드로 상태가 전환

- State 패턴은 그 메소드가 실행될 때
모드도 전환되도록 하는 것

## Command 패턴

- 전략 패턴은 같은 일을 하되 그 알고리즘이나 방식이 갈아끼워지는 것
- command 패턴은 그 하는 일 자체가 다른것

- 출발 버튼을 누르면 차례차례 수행하는 학습용 장난감 코드

```java
package command;

public class Robot {
  public enum Direction { LEFT, RIGHT }

  public void moveForward (int space) {
    System.out.println(space + " 칸 전진");
  }

  public void turn (Direction _direction) {
    System.out.println(
      (_direction == Direction.LEFT ? "왼쪽" : "오른쪽") + "으로 방향전환"
    );
  }

  public void pickup () {
    System.out.println("앞의 물건 집어들기");
  }
}
```
- 메소드로 로봇이 할 수 있는 일들 
- 주어진 칸 숫자만큼 전진하기, 주어진 좌우 반향대로 회전하기, 앞의 물건을 집어올리기

```java
package command;

abstract class Command {
  protected Robot robot;

  public void setRobot (Robot _robot) {
    this.robot = _robot;
  }
  public abstract void execute ();
}

class MoveForwardCommand extends Command {
  int space;
  public MoveForwardCommand (int _space) { 
    space = _space; 
  }
  public void execute () {
    robot.moveForward(space);
  }
}

class TurnCommand extends Command {
  Robot.Direction direction;
  public TurnCommand (Robot.Direction _direction) {
    direction = _direction;
  }
  public void execute () {
    robot.turn(direction);
  }
}

class PickupCommand extends Command {
  public void execute () {
    robot.pickup();
  }
}
```
- execute는 추상 메서드라 인터페이스의 메소드처럼 부모 클래스가 아닌 자식 클래스에서 구현

- MoveForWardCommand는 칸 수를 의미하는 정수 값 space를 인자로 받아서 생성
- TurnCommand 클래스는 방향값과 함께 생성돼서 robot에게 해당 방행대로 전환하는 일을 시킴
- PickupCommand는 필요로 하는 변수 없이 robot이 앞의 물건을 집어올리도록 함

```java
package command;

import java.util.ArrayList;

public class RobotKit {
  private Robot robot = new Robot();
  private ArrayList<Command> commands = new ArrayList<Command>();

  public void addCommand (Command command) {
    commands.add(command);
  }
  public void start () {
    for (Command command : commands) {
      command.setRobot(robot);
      command.execute();
    }
  }
}
```
- Command를 상속한 클래스의 객체들을 담을 ArrayList인 commands

## Adapter

- 형식이 다른 둘 사이에 연결돼서 이 둘이 호환될 수 있도록 해주는 도구
-  인터페이스가 서로 다른 객체들이 같은 형식 아래 작동할 수 있도록 하는 역할

## Proxy
- 인터넷에서 받아와야 해서 시간이 걸리거나 메모리를 많이 차지하거나 하는 등의 이유로 객체로 여럿 생성하기가 부담이 괴는 것들이 있음
- Proxy 대리인 역할