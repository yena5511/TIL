## 1. 객체 지향의 개요

#### 객체의 개념
- 소프트웨어 객체는 세계의 객체를 필드와 메소드로 모델링한 것
- 소프트웨어 객체는 상태를 필드로 정의하고, 동작을 메소드로 정의
- 객체: 현실 세계에서 구체적이거나 추상적인 사물

- 필드 = 멤버 변수: 객체 내부에서 선언된 변수<br>

|변수의 종류|선언위치|생성시기(메모리 할당 시기)|
|:---|:---|:---|
|킇래스 변수|클래스 영역|클래스가 메모리에 올라갈 때|
|인스턴수 변수|클래스 이외의 영역(메소드, 생성자, 초기화 블록)|인스턴스가 생성될 때|
|지역 변수|클래스 이외의 영역(메소드, 생성자, 초기화 블록)|변수 선언문이 수행 되었을 때|

#### 절차 지향 프로그래밍 VS 객체 지향 프로그래밍

|절차지향 프로그래밍|객체지향 프로그래밍|
|:---|:---|
|- 일련의 동작을 숭서에 맞추어 단계적으로 실행하도록 명령어를 나열<br> - 데이터를 정의하는 방법보다는 명령어를 순서와 흐름애 중점<br> - 수행할 작업을 예상할 수 있어 직관적인데, 규모가 작을 때는 프로그래망과 이해하기가 용이|- 스프트웨어의 규모가 커지면서 동작과 분리되어 전 과정에서 서로 복잡하게 얽혀 있는 데이터를 사용했기 때문에 절차지향 프로그래밍 방식의 한계 <br> - 절차지향 프로그램은 추후 변경하거나 확장하기에도 어려움|

## 2. 객체 지향 프로그래밍

#### 특징
- 캡슐화 = 정보 은닉
    - 관련된 필드와 메소드를 하나의 캡슐처럼 포장해 세부 내용을 외부에서 알 수 없도록 감추는 것
- 상속화
    - 자녀가 부모 재산을 상속받아 사용하듯이 상위 객체를 상속받은 하위 객체가 상위 객체의 메서드와 필드를 사용하는 것
- 다형성
    - 대입되는 객체에 따라서 메서즈를 다르게 동작하도록 구현하는 기술
    - 실행 도중 동일항 이름의 다양한 구현체 중애서 메서드를 선택 가능

## 3. 클래스 선언과 객체 생성

#### 추상화 
- 현실세계의 객체는 수많은 상태가 있고 다양한 동작을 하지만, 클래스에 모두 포함하기는 어렵기에 추상화하는 과정이 필요
- 추상화는 현실 새계의 객체에서 불필요한 속성을 제거하고 중욯나 정보만 클래스로 포함하는 일종의 모델링 기법


- 클래스 선언

    - 형식<br>
    ```java
    clss 클래스 이름{
        // 필드;
        // 메서드;
    }
    ```

    - 예<br>
    ```java
    public class Ball{
        double radius = 2.0;
        double getVolime(){
            return 4 / 3 * 3.14 * radius * radius * radius;
        }
    }
    ```

- 클래스 선언과 파일

    - 보통 소스 파일마다 하나의 클래스를 선언하지만, 2개 이상의 클래스를 하나의 파일로 선언 가능
    - 하나의 파일에 클래스가 둘 이상 있다면 하나만 public으로 선언할 수 있고, 해당 클래스 이름은 소스파일 이름과 동일해야 함

- 객체 생성과 참조 변수

    - 객체 변수 선언과 생성<br>
    ```
    클래스 이름 변수;
    변수 = new 클래스 이름()
    ```
    - 변수를 생략한 객체 생성<br>
    ```
    new 클래스 이름();
    ```
    - 한 문장으로 변수 선언과 객체 생성<br>
    ```
    클래스이름 변수 = new 클래스이름();
    ```

#### 4. 클래스의 구성 요소와 멤베 잡근

- 클래스의 구성요소: 멤버, 생성자

|멤버|생성자|
|:---|:---|
|필드, 메서드| - 생성자는 new와 같이 사용되어 클래스로부터 객체를 생성 할 때 호출되어 객체의 초기화를 담당함<br>  - 멤버 변수의 초기화 작업에 주로 사용되어 인스턴스 생성 시 실행 되어야 할 작업을 위해서도 시용됨|

 참고: 지역 변수는 메서드 내부에 선언된 변수. 매개변수도 일종의 지역 변수임

- 필드와 지역 변수의 차이

|필드|지역 변수|
|:---|:---|
|- 초기화하지 않으면 기본 값으로 초기화 됨|- 기본 값이 없기 때문에 초기화 하지 않은 채 사용하면 오류 발생|
|- 클래스 전체에서 사용할 수 있음|- 선언된 후부터 선언된 블록 내부에서만 사용할 수 있음<br> 선언된 위치가 중요함|
|- 모든 접근 지정자뿐만 아니라 static, final로 저장 할 수 있음|-final로만 저장 할 수 있음|


- 클래스 내부에서 멤버 접근
    - 클래스 내부에 있는 멤버인 필드나 메서드는 필드 이름이나 메서드 이름 그대로 사용하면 됨
    - ex) 클래스가 radius 필드와 findArea() 메서드를 포함한다면<br>
    => radius / findArea() 와 같이 그대로 사용<br>
    또는 this.radius / this.findArea()와 같이 자기 자신을 나타내는 this를 붙여서 사용

    ```java
    public class CircleDemo{
        static double radius;

        static double findArea(){
            return 3.14 * radius * radius;
        }

        static void show(double x, double y){
            System.out.printf("반지름 = %.1f, 넓이 = %.1f\n", x, y);
        }

        public static void main(String[] args){
            radius = 10.0;

            double area = findArea();

            show(radius, area);
        }
    }
    ```

    - 내부 필드를 참조하기 때문애 필드이름을 그대로 사용
    - 클래스 내부에서 호출하므로 메서드 이름을 그대로 사용
    

- 클래스 외부애소 멤버 접근

    - 다른 클래스에 있는 멤버를 사용하려면 해당 클래스의 객체를 먼저 생성해야 함
    - 메서드나 필드가 객체에 소속된 멤버이므로 객체가 없다면 접근 할 수 없음
    - 생성된 객체 멤버에 접근하려면 마침표(.) 연산자를 사용해야 함

    ex) 외부 클래스 Circle의 myCircle 객체가 있다면 MyCircle 객체의 멤버 접근 방법

    ```java
    myCircle.radius
    myCircle.findArea()
    ```
    - . -> 객체와 객체 멤버를 연결하는 연산자
    - radius -> 필드 이름/ 인스턴스 변수
    - myCircle -> 사용하려는 외부 객체 이름
    - findArea() -> 메서드 이름/ 인스턴스 메서드

    - radius는 myCircle에만 종속되므로 인스턴스 변수라고 함
    - findArea()는 특정 인스턴스를 생성한 후에만 호출할 수 있으므로 인스턴스 메서드라고 함
    - 인스턴스 변수는 객체마다 따로 있으며, 인스턴스 메서드는 메서드 영역에서 공유됨

## 5. 접근자와 설정자

#### 필요성
- 객체지향 프로그래밍의 주요 특징 중 하나는 캡슐화: 클래스 내부에 감추는 것
- 클래스 멤버를 외부에서 조작할 수 없도록 은닉하려면 멤버 앞에 private으로 지정함
- 클래스 모든 멤버를 private으로 지정하면 어떻게 될까?
=> 외부 클래스에서 해당 클래스를 사용 할 수 없음

#### 접근자와 설정자
- 클래스 내부에 은닉한 필드를 외부에서 사용할 수 있도록 제공하는 것:<br>
=> private으로 지정된 필드에 값을 반환하는 접근자와 값을 변경하는 설정자
- 일반적으로 접근자는 get, 설정자는 set으로 시작하는 이름을 사용
- 필드 이름을 외부와 차단해서 독립시키기 때문에 필드 이름 변경이나 데이터 검증도 가능 

## 6. 생성자

#### 생성자의 의미와 선언

- 생성자의 역할: 객체를 생성하는 시점에서 필드를 다양하세 초기화

- 클래스로 객체를 생성할 때는 객체의 필드를 초기화해야 함
- 클래스에서 필드를 선언할 때 초기화하면 값이 같은 객체만 생성할 수 있고, 클래스에서 필드를 초기화하지 않는다면 기본 값으로 초기화된 객체만 생성할 수 있음
- 일반적인 경우 객체마다 자신의 필드 값을 가지기 때문에 객체를 생성한 수 필드 값을 다시 변경해야 함
- 자바는 객체를 생성하는 시점에서 필드를 다양하게 초기화할 수 있도록 생성자를 제공함

*생성자의 선언 방식*

```
클래스 이름 (...) {...}
```

- 생성자 이름은 클래스 이름과 같음
- 생성자의 반환 타입은 없음
- 생성자는 new 연산자와 함께 사용하며, 객체를 생성할 때 호출함 (자동으로 호출됨)
- 생성자도 오버로딩할 수 있음

*생성자의 사용*
```
클래스이름 변수 = new 클래스이름(); -> 생성자
```

#### 기본 생성자와 생성자 오버로딩
- 모든 클래스는 최소한 하나의 생성자가 있음
- 만약 생성자를 선언하지 않으면 컴파일러가 자동으로 기본 생성자를 추가
- 기본 생성자는 매개변수도 없고 본체에서 실행할 내용도 없는 생성자

#### this와 this()

```java
class Square{
    private double side; 

    public void setRadius(double s){
        side = s;
    }
}
```
- side -> 멤버 필드이다
- s -> 멤버 필드처럼 정사각형 변을 의미하지만, 변수 이름은 다르다.

- side와 s의 의미는 같지만 역할이 다름
- 자바는 객체 자신을 참조할 수 있도록 this 키워드를 제공함 this는 생성자로 생성한 객체 자신을 가리킴

#### 연속 호출
- ex) 반환 타입이 void인 setName(), setAge(), sayHello()라는 메서드를 가진 Person 클래스가 있다고 가정<br>
Person 클래스는 메서드를 호출할 때 마다 새로운 실행문을 사용해야 하므로 번거롭고 가독성이 떨어짐


## 7. 정적 멤버

#### 인스턴스 멤버와 정적 멤버
- 겍체는 자신의 필드를 가짐

|인스턴스 변수|정적 변수 혹은 클래스 변수|
|:---|:---|
|- static 키워드로 지정되지 않아 공유되지 않은 필드로 인스턴스마다 자신의 필드를 생성<br>- 인스턴스 변수는 객체별로 관리<br>- 객체를 생성할 때 인스턴스 변수도 생성하므로 객체를 생성한 후에 접근할 수 있으며 객체가 소멸될 때는 자동으로 소멸됨|- static 키워드로 지정하여 모든 인스턴스가 공유하는 필드<br>- 정적변수는 클래스 로더가 클래스를 메서드 영역에 적재할 때 생성하므로 객체 생성 전에도 접근 가능<br>- 객체를 여러개 생성해도 정적 변수는 하나 뿐 모든 객체가 공유하므로 클래스 변수라고도 함|

|인스턴스 메소드|정적 메소그(대표적인 예는 main)|
|:---|:---|
|- 객체를 생성한 후 호출가능|- 정적 변수처럼 객체를 생성하기 전에도 호출 할 수 있음|

*정적 메소드의 유의 사항*
- 객체와 관련된 인스턴스 변수를 사용할 수 없음
- 객체와 관련된 인스턴스 메서드를 호출할 수 없음
- 객체 자신을 가리키는 this 키워드를 사용할 수 없음
- 정적 메서드는 정적 변수와 지역 변수를 사용할 수 있음
- 또 다른 정적 메서드를 호출할 수 있으며, 생성자도 호출할 수 있음
- 정작 메서드가 객체와 관련괸 인스턴스 변수를 참조하거나 인스턴스 메서드를 호출할 때는 오류가 발생함
- 인스턴스 변수나 인스턴스 메서드가 필요하가면 먼저 객체를 생성한 후 사용해야 함

#### 정적 멤버의 활용 

- 정적 멤버는 인스턴스 멤버와 달리 객체를 생성하기 전이라도 사용할 수 있기 때문에 일반적으로 객체 이름 대신에 클래스 이름과 연결해서 사용함

```
클래스 이름.정적변수이름
클래스 이름.정적메서드이름()
```

- 정적 변수의 대표적인 예: 상수
    - 상수는 변경되지 않는 변수이기 때문에 final 키워드로 지정
    - 상수는 값이 변경되지 않으므로 객체마다 따로 기억 공간을 가질 필요가 없음<br>
    따라서 상수는 공유해도 되기 때문에 일반적으로 static final로 지정해서 선언함<br>
    ```java
    static final 데이터형 상수 = 초긱값
    ```

    