## Cookie

쿠키는 일종의 서버와 클라이언트가 대화하기 위한 수단
- 브라우저가 서버와 연결이 되어있을 때 브라우저에서 자동적으로 쿠키를 생성하고, response 할 때 쿠키를 담아서 보낸다
- 특정 호스트에서 생성된 쿠키는 이후 모든 요청마다 서버에 전송된
- 요청 해더의 set-cookie 속성에 정보를 담을 수 있음
- 쿠키에 담긴 데이터는 브라우저에서 관리함
- 이름, 값, 만료 날짜, 경로 정보로 구성

## Session

서버와 클라이언트의 연결이 활성화된 상태

- 클라이언트가 서버와 통신을 시작하면 서버는 해당 클라이언트에 대해 유일한 값인 세션 id를 부여, 세션 스토리지에 세션 정보를 저장함
- 클라이언트는 이 세션 id를 쿠키를 통해 기억함
- 이후 클라이언트가 어떤 요청을 보낼 때마다 헤더의 cookie에 세션 id를 담아서 전송함
- 서버는 클라이언트가 보낸 요청의 쿠키에 담딘 세션 id와 세션 스토리지에 담긴 세션 id를 대조해 인증 상태를 판단<br>
(즉, 세션과 쿠키는 완전히 분리된 개념이 아니며 세션은 쿠키를 기반으로 함)
- 각 클라이언트마다 유니크한 세션 객체가 주어지고, 이 세션 객체에 데이터를 담아 관리할 수도 있음<br>
(세션 객체가 자물쇠로 잠긴 상자라면 세션 id가 열쇠인 셈)
- 세션을 사용하지 않고 쿠키만으로 어떤 데이터를 주고 받는다면, 클라이언트는 이미 모든 데이터를 알고 있다는것

![](https://velog.velcdn.com/images%2Fkingth%2Fpost%2F4de3d293-962f-4d27-957a-6f9e66b8e3fd%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-09-06%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%209.59.33.png)

1. 사용자 로그인 요청
2. 서버에서 계정 정보를 읽어 사용자를 확인 하고, 사용자의 고유한 ID를 부여하여 세션 저장소에 저장한 후, 이와 연결된 세션 ID를 발급한다
3. 사용자는 서버에서 해당 세션 ID를 받아 쿠키에 저장한 후, 인증이 필요한 요청마다 쿠키를 헤더에 실어 보낸다
4. 서버는 쿠키를 받아 세션 저장소에서 대조 후 대응되는 정보를 가져온다
5. 인증이 완료 되고 서버는 사용자에 맞는 데이터를 보내준다

쿠키만으로 인증을 사용한다는 것은 서버의 자원은 사용하지 않는다는 것이며, 즉 클라이언트가 인증 정보를 책임지게 된다
클라이언트에 모든 인증정보가 담겨 있다면 HTTP reqest가 해커의 의해 탈취 당했을 경우 사용자 정보를 털리게 되는 것이다
그래서 장바구니나 자동 로그인 설정의 경우 유용하게 쓰인다

결과적으로 Session/Cookie 인증 방식을 사용하는 이유는 서버에서 인증의 책임을 전가하는 것이다

#### 장점

- 세션/쿠키 방식은 기본적으로 쿠키를 매개로 인증을 거친다
여기서 쿠키는 세션 저장소에 담긴 유저 정보를 얻기 위한 열쇠라고 보면 된다
따라서 쿠키가 담긴 HTTP요청이 도중에 노출되더라도 쿠키 자체(세션 ID)는 유의미한 값을 갖고있지 않다(중요한 정보는 서버 세션에)
- 사용자 A는 1번, 사용자 B는 2번 이런식으로 고유의 ID값을 발급받게 된다
그렇게 되면 서버에서는 쿠키 값을 받았을 때 일일이 회원정보를 확인할 필요없이 바로 어떤 회원인지를 확인할 수 있어 서버의 자원에 접근하기 용이할 것이다

#### 문제점

하지만 이렇게 복잡한 과정을 거치더라도 완벽한  보안은 없다
이미 인증된 사용자의 HTTP요청을 해커가 가로 챘다면 그 안의 Cookie도 탈취가 가능하다
그래서 해커가 인증된 사용자의 Cookie를 실어 서버에 요청을 보내면 서버는 인증된 사용자인지, 해커인지 구별할 방법이 없다

#### 해결법

- HTTPS사용, 서버와 클라이언트 간의 주고받는 정보를 암호화하여 요청을 탈취해도 정보를 읽을 수 없다
- 세션에 유효기간을 지정한다(일정 시간이 지나면 해당 클라이언트와 서버와의 세션을 끊는다)