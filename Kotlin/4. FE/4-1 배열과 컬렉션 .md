## 코틀린에서 배열과 컬렉션을 다루는 법

#### 배열

> 출력 방법
```kotlin
fun main(){

    val array = arrayOf(100, 200)

    for (i in array.indices) {

        println("${i} ${array[i]}")
    }

}
```

```kotlin
fun main(){

    val array = arrayOf(100, 200)

    for ((idx, value) in array.withIndex()) {
        println("$idx $value")
    }

}
```

array.indices는 0부터 마지막 index까지의 Range이다

withIndex()를 사용하면, 인덱스의 값을 한 번에 가져올 수 있다

값을 쉽게 추가 가능

#### 코틀린에서의 Collection - List

컬렉션을 만들어줄 때 불변인지, 가변인지를 설정해야 한다

- 가변(Mutable)컬렉션: 컬렉션에 element를 추가, 삭제할 수 있다
- 불변 컬렉션: 컬렉션에 element를 추가, 삭제할 수 없다
    - 불변 컬렉션이라 하더라고 Reference Type인 Element의 필드는 바꿀 수 있다

```kotlin
fun main(){

    val mumbers = listOf(100, 200)
    val emptyList = emptyList<Int>()
}
```
- listOf를 통해 '불변 리스트'를 만든다
- emptyList<타입>() 비어있는 리스트

> 타입을 추론할 수 있다면 생략 가능
```kotlin
fun main(){
       printNumbers(emptyList)
    }

private fun printNumbers(mumbers: List<Int>) {

}
```

> 출력
```kotlin
 fun main(){

       val numbers = listOf(100, 200)
       
       // 하나 가져오기
       println(numbers[0])

       // For Each
       for(number in numbers){
           println(numbers)
       }

       // 전통적인 For문
       for ((index, number) in numbers.withIndex()){
           println("$index $number")
       }

    }
```

> 가변 리스트
```kotlin
val numbers = mutableListOf(100, 200)
       numbers.add(300)
```

#### 코틀린에서의 Collection - Set

집합은 List와 다르게 순서가 없고, 같은 element는 하나만 존재할 수 있다
        
자료구조적 의미만 제외하면 모든 기능이 List와 비슷

> 집합
```kotlin
   fun main(){

       val numbers = setOf(100, 200)
       
       // For Each
       for(number in numbers){
           println(numbers)
       }

       // 전통적인 For문
       for ((index, number) in numbers.withIndex()){
           println("$index $number")
       }
```

> 가변 집합
```kotlin
val numbers = mutableListOf(100, 200)
```

기본 구현체는 LinkedHasSet


#### 코틀린에서의 Collection - Map 

```kotlin
 fun main(){

       val oldMap = mutableMapOf<Int, String>()
       oldMap.put(1, "MONDAY")
       oldMap[2] = "TUESDAY"

       mapOf(1 to "MONDAY", 2 to "TUESDAY")
}
```
- 타입을 추론할 수 없어, 지정해줘야한다
- Java처럼 put을 쓸 수 있고, map[key] = value을 쓸 수도 있다
- mapOf(key to value)를 사용해 불변 map을 만들 수 있다

Kotlin도 동일하게 MutableMap을 만들어 넣을 수도 있고, 정적 팩토리 메소드를 바로 활용할 수도 있다

> 값 가져오기
```kotlin
  val oldMap = mutableMapOf<Int, String>()
       oldMap.put(1, "MONDAY")
       oldMap[2] = "TUESDAY"

      for (key in oldMap.keys){
          println(key)
          println(oldMap[key])
       }
       
       for ((key, value) in oldMap.entries){
           println(key)
           println(value)
       }
```