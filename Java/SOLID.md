## 객체 지향 설게의 5가지 원칙 

- SRP: 단일 책임 원칙
- OCP: 개발 폐쇄 원칙
- LSP: 리스코프 치환 원칙
- ISP: 인터페이스 분리 원칙
- DIP: 의존 역전 원칙

#### SRP: 단일 책임 원칙

`한 클래스는 하나의 책임만 가져야 한다.`

모든 클래스는 각각하나의 책임만 가져야 하며, 수정할 이유는 단 한 가지여야 한다.
즉, 클래스는 그 책임을 완전회 캡슐화해야 함을 말한다.

예를들어, 결제 클래스가 있다 이 클래스는 오직 결제 기능만을 책임지고
만약 이 클래스를 수정해야 한다면 결제 관련된 문제일 뿐 일 것이다.

#### OCP: 개발 폐쇄 원칙

`소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야 한다.`

이는 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소는 수정이 일어나지 않아야하며 쉽게 확장이 가능하여 재상용할 수 있어야 한다.
로버트 마틴은 OCP는 관리가 용이하고 재사용 가능한 코드를 만드는 기반이며, OCP를 가능케 하는 중요한 메커니즘은 추상화(Abstraction)와 다형성(Polymorphism)이라고 설명한다.
OCP는 객체지향의 장점을 극대화하는 아주 중요한 원리이다.

![](https://velog.velcdn.com/images%2Ffalling_star3%2Fpost%2Ffacc7370-9cda-48ba-a084-3e6fb0ca24b2%2Fimage.png)

위의 운전자 클래스는 마티지 클래스와 소나타 클래스의 변환에 따라 행동이 의존적으로 변하게 된다.
다음과 같이 마티즈 클래스와 소나타 클래스 위에 자동차하는 상위 클래스를 두면, 운전자는 마티즈와 소나타 클래스의 변경사항에 영향을 받지 않을 수 있다.

![](https://velog.velcdn.com/images%2Ffalling_star3%2Fpost%2Ffacc7370-9cda-48ba-a084-3e6fb0ca24b2%2Fimage.png)

이처럼 클래스를 설계할 때 변할 부분과 변하지 않을 부분을 명확히 구분해야한다.
변할 수 있는 부분은 추상화하여 상속하는 클래스가 의존할 수 있게 코드를 작성한다.

#### LSP: 리스코프 치환 원칙

`서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.`

프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
이는 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것을 말하며, 다형성을 지원하기 위한 원칙이다.
인터페이스를 구현한 구현체는 믿고 사용하려면 이 원칙이 필요하다.
상속을 잘 활용하고 있다면, 이미 LSP는 잘 구현하고 있는 것이다.

![](https://velog.velcdn.com/images%2Ffalling_star3%2Fpost%2F2de4fb89-451e-40bb-a022-01357916dd49%2Fimage.png)

LSP를 잘 구현한 사례 : 박쥐는 포유류의 역할을 할 수 있다.

LSP 위반 사례 : 딸은 아버지의 역할을 할 수 없다.


쉬운 예시를 하나 더 들자면, 자동차 인터페이스의 엑셀은 앞으로 가게 하는 기능인데 이를 뒤로 가게 구현하면 LSP를 위반한 것이다. 
느리더라도 앞으로 가게 구현해야 한다.

#### ISP: 인터페이스 분리 원칙

`클라이언트는 자신이 사용하지 않는 메서드에 의전 관계를 맺으면 안 된다.`

이는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원칙이다.

특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다는 뜻으로, 하나의 큰 인터페이스를 상속 받기 보다는 인터페이스를 구체적이고 작은 단위들로 분리시켜 꼭 필요한 인터페이스만 상속하자는 의미이다.

SRP가 클래스의 단일책임을 강조했다면 ISP는 인터페이스의 단일책임을 강조한다.

#### DIP: 의존관계 역전 원칙

`추상화된 것은 구체적인 것에 의존하면 안된다.
구체적인 것이 추상화된 것에 의존해야 한다.`

구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻이다.
구현체에 의존하게 되면 변경이 아주 어려워진다.

즉, 인터페이스를 적극적으로 활용하라는 의미이다.


