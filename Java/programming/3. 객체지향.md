## 1. 객체 지향의 개요

#### 객체의 개념
- 소프트웨어 객체는 세계의 객체를 필드와 메소드로 모델링한 것
- 소프트웨어 객체는 상태를 필드로 정의하고, 동작을 메소드로 정의
- 객체: 현실 세계에서 구체적이거나 추상적인 사물

- 필드 = 멤버 변수: 객체 내부에서 선언된 변수<br>

|변수의 종류|선언위치|생성시기(메모리 할당 시기)|
|:---|:---|:---|
|킇래스 변수|클래스 영역|클래스가 메모리에 올라갈 때|
|인스턴수 변수|클래스 이외의 영역(메소드, 생성자, 초기화 블록)|인스턴스가 생성될 때|
|지역 변수|클래스 이외의 영역(메소드, 생성자, 초기화 블록)|변수 선언문이 수행 되었을 때|

#### 절차 지향 프로그래밍 VS 객체 지향 프로그래밍

|절차지향 프로그래밍|객체지향 프로그래밍|
|:---|:---|
|- 일련의 동작을 숭서에 맞추어 단계적으로 실행하도록 명령어를 나열<br> - 데이터를 정의하는 방법보다는 명령어를 순서와 흐름애 중점<br> - 수행할 작업을 예상할 수 있어 직관적인데, 규모가 작을 때는 프로그래망과 이해하기가 용이|- 스프트웨어의 규모가 커지면서 동작과 분리되어 전 과정에서 서로 복잡하게 얽혀 있는 데이터를 사용했기 때문에 절차지향 프로그래밍 방식의 한계 <br> - 절차지향 프로그램은 추후 변경하거나 확장하기에도 어려움|

## 2. 객체 지향 프로그래밍

#### 특징
- 캡슐화 = 정보 은닉
    - 관련된 필드와 메소드를 하나의 캡슐처럼 포장해 세부 내용을 외부에서 알 수 없도록 감추는 것
- 상속화
    - 자녀가 부모 재산을 상속받아 사용하듯이 상위 객체를 상속받은 하위 객체가 상위 객체의 메서드와 필드를 사용하는 것
- 다형성
    - 대입되는 객체에 따라서 메서즈를 다르게 동작하도록 구현하는 기술
    - 실행 도중 동일항 이름의 다양한 구현체 중애서 메서드를 선택 가능

## 3. 클래스 선언과 객체 생성

#### 추상화 
- 현실세계의 객체는 수많은 상태가 있고 다양한 동작을 하지만, 클래스에 모두 포함하기는 어렵기에 추상화하는 과정이 필요
- 추상화는 현실 새계의 객체에서 불필요한 속성을 제거하고 중욯나 정보만 클래스로 포함하는 일종의 모델링 기법


- 클래스 선언

    - 형식<br>
    ```java
    clss 클래스 이름{
        // 필드;
        // 메서드;
    }
    ```

    - 예<br>
    ```java
    public class Ball{
        double radius = 2.0;
        double getVolime(){
            return 4 / 3 * 3.14 * radius * radius * radius;
        }
    }
    ```

- 클래스 선언과 파일

    - 보통 소스 파일마다 하나의 클래스를 선언하지만, 2개 이상의 클래스를 하나의 파일로 선언 가능
    - 하나의 파일에 클래스가 둘 이상 있다면 하나만 public으로 선언할 수 있고, 해당 클래스 이름은 소스파일 이름과 동일해야 함

- 객체 생성과 참조 변수

    - 객체 변수 선언과 생성<br>
    ```
    클래스 이름 변수;
    변수 = new 클래스 이름()
    ```
    - 변수를 생략한 객체 생성<br>
    ```
    new 클래스 이름();
    ```
    - 한 문장으로 변수 선언과 객체 생성<br>
    ```
    클래스이름 변수 = new 클래스이름();
    ```

#### 4. 클래스의 구성 요소와 멤베 잡근

- 클래스의 구성요소: 멤버, 생성자

|멤버|생성자|
|:---|:---|
|필드, 메서드| - 생성자는 new와 같이 사용되어 클래스로부터 객체를 생성 할 때 호출되어 객체의 초기화를 담당함<br>  - 멤버 변수의 초기화 작업에 주로 사용되어 인스턴스 생성 시 실행 되어야 할 작업을 위해서도 시용됨|

 참고: 지역 변수는 메서드 내부에 선언된 변수. 매개변수도 일종의 지역 변수임

- 필드와 지역 변수의 차이

|필드|지역 변수|
|:---|:---|
|- 초기화하지 않으면 기본 값으로 초기화 됨|- 기본 값이 없기 때문에 초기화 하지 않은 채 사용하면 오류 발생|
|- 클래스 전체에서 사용할 수 있음|- 선언된 후부터 선언된 블록 내부에서만 사용할 수 있음<br> 선언된 위치가 중요함|
|- 모든 접근 지정자뿐만 아니라 static, final로 저장 할 수 있음|-final로만 저장 할 수 있음|


- 클래스 내부에서 멤버 접근
    - 클래스 내부에 있는 멤버인 필드나 메서드는 필드 이름이나 메서드 이름 그대로 사용하면 됨
    - ex) 클래스가 radius 필드와 findArea() 메서드를 포함한다면<br>
    => radius / findArea() 와 같이 그대로 사용<br>
    또는 this.radius / this.findArea()와 같이 자기 자신을 나타내는 this를 붙여서 사용

    ```java
    public class CircleDemo{
        static double radius;

        static double findArea(){
            return 3.14 * radius * radius;
        }

        static void show(double x, double y){
            System.out.printf("반지름 = %.1f, 넓이 = %.1f\n", x, y);
        }

        public static void main(String[] args){
            radius = 10.0;

            double area = findArea();

            show(radius, area);
        }
    }
    ```

    - 내부 필드를 참조하기 때문애 필드이름을 그대로 사용
    - 클래스 내부에서 호출하므로 메서드 이름을 그대로 사용
    

- 클래스 외부애소 멤버 접근

    - 다른 클래스에 있는 멤버를 사용하려면 해당 클래스의 객체를 먼저 생성해야 함
    - 메서드나 필드가 객체에 소속된 멤버이므로 객체가 없다면 접근 할 수 없음
    - 생성된 객체 멤버에 접근하려면 마침표(.) 연산자를 사용해야 함

    ex) 외부 클래스 Circle의 myCircle 객체가 있다면 MyCircle 객체의 멤버 접근 방법

    ```java
    myCircle.radius
    myCircle.findArea()
    ```
    - . -> 객체와 객체 멤버를 연결하는 연산자
    - radius -> 필드 이름/ 인스턴스 변수
    - myCircle -> 사용하려는 외부 객체 이름
    - findArea() -> 메서드 이름/ 인스턴스 메서드

    - radius는 myCircle에만 종속되므로 인스턴스 변수라고 함
    - findArea()는 특정 인스턴스를 생성한 후에만 호출할 수 있으므로 인스턴스 메서드라고 함
    - 인스턴스 변수는 객체마다 따로 있으며, 인스턴스 메서드는 메서드 영역에서 공유됨

