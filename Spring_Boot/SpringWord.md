## Spring

#### 1.1 스프링의 개념
스프링은 자바 기반의 웹 어플리케이션을 만들 수 있는 프레임워크이다.
스프링의 구조는 아래와 같은 구조로 이루어져있다.
![Alt text](https://melonicedlatte.com/assets/images/2021_3Q/spring_architect.png)

#### 1.2 스프링의 특징
Spring은 자바 객체와 라이브러리들을 관리해주며, 톰캣과 같은 WAS 가 내장되어 있어 자바 웹 어플리케이션을 구동할 수 있다.<br>
spring은 경량 컨테이너로 자바 객체를 직접 spring 안에서 관리한다. 객체의 생성 및 소멸과 같은 생명 주기를 관리하며, spring 컨테이너에서 필요한 객체를 가져와 사용한다.<br>
- Spring의 가장 큰 특징으로 IOC와 DI가 많이 언급됩니다. IOC와 DI의 간단한 개념은 아래와 같습니다.<br>
    - 제어의 역전 (IOC, Inversion Of Control)<br>
         - 일반적으로 처음에 배우는 자바 프로그램에서는  모든 작업을 사용자가 제어하는 구조였다. 예를 들어 A 객체에서 B 객체에 있는 메소드를 사용하고 싶으면, B 객체를 직접 A 객체 내에서 생성하고 메소드를 호출합니다.<br>
         - 하지만 IOC가 적용된 경우, 객체의 생성을 특별한 관리 위임 주체에게 맡깁니다. 이 경우 사용자는 객체를 직접 생성하지 않고, 객체의 생명주기를 컨트롤하는 주체는 다른 주체가 됩다. 즉, 사용자의 제어권을 다른 주체에게 넘기는 것을 IOC(제어의 역전) 라고 합니다.<br>
         - 요약하면 Spring의 Ioc란 클래스 내부의 객체 생성 -> 의존성 객체의 메소드 호출이 아닌, 스프링에게 제어를 위임하여 스프링이 만든 객체를 주입 -> 의존성 객체의 메소드 호출 구조입니다. 스프링에서는 모든 의존성 객체를 스프링이 실행될때 만들어주고 필요한 곳에 주입해줍니다.<br>
    ● 의존성 주입 (DI, Dependency Injection)<br>
         - 어떤 객체(B)를 사용하는 주체(A)가 객체(B)를 직접 생성하는게 아니라 객체를 외부(Spring)에서 생성해서 사용하려는 주체 객체(A)에 주입시켜주는 방식이다. 사용하는 주체(A)가 사용하려는 객체(B)를 직접 생성하는 경우 의존성(변경사항이 있는 경우 서로에게 영향을 많이 준다)이 높아진다. 하지만, 외부(Spring)에서 직접 생성하여 관리하는 경우에는 A와 B의 의존성이 줄어든다.<br>

## Spring Boot

#### 스프링 부트의 개념

스프링 부트(Spring Boot)는 스프링(Spring)을 더 쉽게 이용하기 위한 도구라고 볼 수 있다. 스프링 이용하여 개발을 할 때, 이것저것 세팅을 해야 될 요소들이 많다. 여러가지를 세팅해야되는 진입 장벽이 존재하여 Spring 을 처음 배우려는 사람들은 중도에 그만두는 경우가 많다고 한다. Spring Boot는 매우 간단하게 프로젝트를 설정할 수 있게 하여, Spring 개발을 조금 더 쉽게 만들어주는 역할을 하고 있다.

## IoC(Inversion of Control)
: 프레임워크 기반의 개발에서는 프레임워크가 필요할 때마다 애플리케이션 코드를 호출하여 사용하는데
이 때 제어권을 가지는 것이 컨테이너(Container)이다.
객체에 대한 제어권을 컨테이너가 가지고 객체의 생성부터 생명주기 관리 등을 컨테이너가 맡아서 하면서
제어권의 흐름이 개발자에서 컨테이너로 바뀌었다고 해서 IoC(Inversion of Control)라고 부름
#### IOC 용어
- bean : 스프링에서 제어권을 가지고 직접 만들어 관계를 부여하는 오브젝트(스트링 컨테이너가 생성하고 관계설정, 사용을 제어해주는 오브젝트)
- bean factory : 스프링의 IoC를 담당하는 핵심 컨테이너
Bean을 등록/생성/조회/반환/관리 (보통 bean factory를 바로 사용하지 않고 이를 확장한 application context를 이용)
BeanFactory는 bean factory가 구현하는 interface이다. (getBean()등의 메서드가 정의되어 있다.)
- application context : bean factory를 확장한 IoC 컨테이너
bean factory에 추가로 spring의 각종 부가 서비스를 제공ApplicationContext는 application context가 구현해야 하는 interface, BeanFactory를 상속
- container (ioC container) : IoC 방식으로 bean을 관리한다는 의미(bean factory나 application context를 가리킴)
하나의 애플리케이션에 보통 여러개의 ApplicationContext 객체가 만들어짐-> 모두 합해서 spring container라고 부를 수 있다.

#### 의존 주입 DI(Dependency Injection)
: 어떠한 객체가 다른 객체를 필요로 함에 따라 setter나 생성자를 사용하여 필요로 하는 객체를 주입시켜 기능을 사용할 수 있게 하는 것 (또는 직접 주입 가능)

#### WAS (Web Application Server)
: WAS는 일종의 미들웨어로 웹 클라이언트(보통의 웹 브라우저)의 요청 중 웹 애플리케이션이 동작하도록 지원하는 목적을 가진다.(Tomcat)

## Domain Driven Design(DDD)

- Domain: 온라인서점 사이트에서 책을 조회하고 구매한다고 가정하자. 개발자 입장에서 온라인서점은 구현해야할 소프트웨어의 대상이 된다. 온라인서점 소프트웨어는 상품의 조회, 구매, 결제등의 기능을 제공해야한다. 이때 온라인 서점은 소프트웨어로 해결하고자하는 문제 영역, 즉 도메인(domain)에 해당된다.

- Entity: Entity모델에서의 객체는 `Entity`이고
`Entity`는 다른 Entity와 구별할 수 있는 `식별자`를 가진다.
Entity는 객체의 상태가 계속 변한다.
Entity의 `식별자`는 고유하기 때문에 `도메인`에서 개별성이 있는 개념이라고 생각하면 된다.


- Value Object: Value Object는 값 객체라고 불린다.
Value Objec는 값 속성이 개별적으로 변하지 않고 값 자체로 고유한 객체를 뜻한다.
엔티티가 `id`로 고유성을 가진다면 Value는 `값의 조합`으로 고유성을 가진다.
그리고 한 번 만들어지면 내용이 변하지 않는다.

#### API
:Application Programming Interface의 줄임말로 응용 프로그램에서 사용할 수 있도록, 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻합니다.

#### Interface
:클라이언트 프로그램에서 구현을 보지 않고도 객체를 사용할 수 있는 매개체 역할을 하고, 공통적인 목적을 갖고있는 클래스들의 틀을 제공하는 역할을 한다. 
 
 #### Controller
 :Controller는 창구 역할을 하는 API들을 모아놓은 클래스이다.
당연히 정보를 프론트 쪽으로 내려줄 때도 이 컨트롤러의 API를 통해서 보내준다.


#### Repository
: Repository는 직역해도 '저장소'로 데이터베이스와 깊은 연관이 있음을 알 수 있다. 데이터단에 직접 매칭되는 Entity라는 것이 있는데, 이 Entity를 통해 데이터 테이블이 생성이 되면, 받아온 정보를 데이터베이스(ex. MySQL, mariaDB)에 저장하고 조회하는 기능을 수행한다.

#### Service
: Service는 위에서 언급했듯이 Repository에서 얻어온 정보를 바탕으로 자바 문법을 이용하여 가공 후 다시 Controller에게 정보를 보내는 곳이다.
어떻게 보면 Controller는 클라이언트에, Repository는 데이터에 맞닿아서 정보를 주고받는 부분으로 여길 수 있으나 실질적으로 중요한 작동이 많이 일어나는 부분이라고 할 수 있다.


컨트롤러 : @Controller (프레젠테이션 레이어, 웹 요청과 응답을 처리함) <br>
로직 처리 : @Service (서비스 레이어, 내부에서 자바 로직을 처리함) <br>
외부I/O 처리 : @Repository (퍼시스턴스 레이어, DB나 파일같은 외부 I/O 작업을 처리함)


#### JDBC
: Java에서 데이터베이스에 접근할 수 있는 Java 인터페이스를 의미한다.


#### @GetMapping
- @RequestMapping(method = RequestMehtod.GET)의 축약형으로써, 어노테이션만 보고 무슨 메소드 요청인지 바로 알아볼 수 있다.
- @GetMapping은 요청 URL을 어떠한 메서드가 처리할 지 매핑한다.
- Controller 내부에서 URI 경로를 지하정는 역할도 한다.



#### Factory
:  특정 오브젝트를 요구하면서 오브젝트를 생성하거나 가져오는 방식을 신경쓰지 않도록 중간에서 역할하는 오브젝트


#### AOP
핵심 로직과 부가 기능을 분리하여 애플리케이션 전체에 걸쳐 사용되는 부가 기능을 모듈화하여 재사용할 수 있도록 지원하는 것


#### Proxy

사전적의미 : 대략 누군가를 대신하여 뭔가를 수행하는 권한 자체 또는 그 권한을 받은 주체를 뜻한다

#### Proxy server

프록시 서버는 Client와 Server간에 주고받는 네트워크 요청과 응답 사이에 위치하는 서버이다
여러가지 이유로 사용되는데, 캐싱 또는 사용자 보호의 이유로 쓰인다

캐싱의 경우에는 고속 인터넷 연결이 가능한 건물 상에 프록시서버를 설치하고, 사용자 요청이 들어오면 캥싱되어 있는 페이지 중에 있는지 확인하고 없으면 요청해서 받아오거나 이전 버전으라면 업데이트해서 보여주는 역할

두 번째 이유는 사용자 개인정보 보호를 위해 쓰이는데, 사용자는 직접 서버에 요청하는 것이 아니라 프록시 서버에 요청을 보낸다
그럼 프록시 서버는 사용자의 IP address가 아닌 새 공인 아이피를 생성해서 서버에 요청을 보낸다
그럼 서버는 사용자의 IP를 알지 못한 채 프록시 서버의 요청에 응답해줄 뿐이다
프록시 서버는 이 응답을 받아 원래 요청을 했던 client 의 IP로 응답을 전달해준다
즉, 사용자와 서버 사이에서 중계를 해주는 것이다

- proxy server의 장점
     - IP주소를 가릴 수 있다
     - 로딩에 걸리는 시간을 줄일 수 있을지도 모른다
     - 제한된 웹사이트를 우회하여 접속할 수 있다
     - 캐싱을 이용하여 시스템의 성능을 올린다

- proxy server의 단점
     - 캐싱하는 과정에서 proxy 서버 관리자에세 쉽게 개인정보가 노출될 위험이 있다
     - TLS/SSL을 사용하면 데이터와 정보가 유출될 수 있다


#### Spring Proxy

#### 프록시 패턴

프록시 객체는 원래 객체를 감싸고 있는 같은 타입의 객체이다
프록시 객체가 원래 객체를 감싸서 client의 요청을 처리하게 하는 패턴이다
쓰는 이유는 접근을 제어하고 싶거나, 부가 기능을 추가하고 싶을 때 주로 사용한다

#### AOP

AOP는 `Aspect Oriented Progtamming` 이다 
`관점 지향 프로그래밍`으로 번역되며 중심적인 역할은 기능들 사잉에 공유하는 관심사항을 삽입하여 코드의 중복을 줄이는 방식의 패러다임이다

간단히 예를 들면, 우리가 만든 프로그램에 모든 메소드 호출 시마다 로그를 찍고 싶다
사실 로그를 찎는 것은 핵심 모듈이 아니기에 개발한 코드에는 로그를 찍는 기능은 개발이 되어 있지 않을 것 이다
그럼 무수한 메소드에 직접 로그를 입력하는 함수를 짜야하는데, 메우 고통스러운 일이다

또한 객체지향의 관점에서 핵심 로직이 이런 부수적인 기능을 책임져야 한다는 것은 관심사의 분리에 어긋난다고 생각된다
그래서 스프링 AOP라는 이름으로 부수적인 기능을 책임져줄 기능을 만들었다고 생각한다
이는 의존관계 설정을 도맡아 해주는 Ioc기법인 DI와 유사해보인다

AOP는 핵심 모듈 사이에 필요한 기능을 삽입하여 적절한 타이밍에 호출되도록 해주는 기능이다
이를 구현할 때 스프링은 대상 빈을 프록시로 감싸는 방법을 활용한다

#### 포록시

어떠한 클래스(빈)가 AOP 대상이면 원본 클래스 대신 프록시가 감싸진 클래스가 자동으로 만들어져 프록시 클래스가 빈에 등록 된다
이렇게 빈에 등록된 프록시 클래스는 원본클래스가 호출되면 자동으로 바꿔서 사용해준다
이 방식을 통해 자연스럽게 OCP를 만족한다

관련 용어

- Advice: Joinpoint에서 실행되어야 하는 코드, 공통 관십사, 횡단 관점에 해당한다
언제 어떤 부수적인 기능을 핵심 로직에 적용할지를 담고있다
- Target: 핵심 로직을 담고 있는 객체에 해당한다
Advice의 적용 대상이며 비지니스 로직을 수행하는 클래스나 프록시 객체가 될 수 있다
- Joinpoint: Advice가 적용가능한 지점을 의미하며, 메소드를 호출하는 시점, 예외가 발생하는 시점과 같이 애플리케이션을 실행할 때 특정 작업이 실행되는 시점을 의미한다
이 때, 프록시를 활용했으므로 객체 내부의 호출 없이 이뤄지는 필드 수정 등의 joinpoint는 활용할 수 없다
- Pointcut: 가능한 joinpoint중 실제 Advice가 적용된 joinpoint를 의미한다
스프링에소 Aspectj 등을 통해 Target과 Advice가 결합 될 때 둘 사이의 결합 규칙 
(Advice가 실행된 Target의 특정 메소드 등을 지정)을 정의할 수 있다
- Aspect: Advice과 Pointcut을 합쳐서 하나의 Aspect라고 한다
AOP에서 말하는 Aspectj는 한마디로 어떤 관심사를 어떤 지점에 넣을 것인지를 말한다고 보면 된다
- Weaving: AOP에서 joinpoint들을 Advice로 감싸는 과정이다
이 작업을 도와주는 것이 Aspectj등의 AOP툴이 하는 역할이다

#### redirect

redirect: 서버가 클라이언트에게 요청할 주소를 응답결과로 전달하는 것을 의미한다

- redirect 흐름
1. 클라이언트에서 서버로 첫 번째 URL로 요청한다
2. 서버에서 첫 번째 URL로 받고 두 번째 URL로 redirect처리한다
3. Location응답헤더에 HTTP status Code 302와 두번 째 URL을 담아소 클라이언트에 전송한다
4. 클라이언트에서 Location응답헤더에 있는 302응답코드를 확인하고 두번째 URL로 재요청한다
(클라이언트는 응답결과로 받은 요청주소를 직접 요청)
(브라우저가 요청하는 것이므로 주소창의 URL주소는 변경)
(새로운 요청이기 때문에 request와 response는 새롭게 생성, HttpSession 객체는 유지)
5. 서버에서 요청 받은 두 번째 URL 응답한다

- redirect 예시

1. 사용자(클라이언트)가 고객센터 상담원(서버)1(첫번째 URL)에게 전화를 겁니다.

2. 상담원(서버)1(첫번째 URL)은 문의사항을 잘 이해하지 못하여 상담원(서버)2(두번째 URL)의 전화번호를 알려줬습니다.

3. 사용자(클라이언트)는 다시 상담원(서버)2(두번째 URL)에게 전화를 걸어 문의를 처리합니다.

#### forward

forward: 코드의 흐름을 서버상에서만 이동하는 것을 의미한다

- forward 흐름
1. 클라이언트에세 서버로 첫 번째 URL로 요청한다
2. 서버네서 첫 번째 URL로 받고 두 번째 URL로 바로 forward 처리한다
3. 서버에서 두번째 URL 바로 호출한다
(서블릿 컨테이너는 해당 요청을 그대로 타겟 URL로 포워딩 시킨다)
(브라우저는 다은 곳으로 흐름이 이동되었다는 것을 알 수 없기 떄문에 주소창에 URL주소는 변경되지 않는다)
(request와 response, HttpSession 객체 모두 유지한다)
4. 서버에서 요청 받은 두 번째 URL응답한다
(응답은 redirect와 다르게 두 번째 URL에 대한 응답 한번만 내려온다)

- forward 예시

1. 사용자(클라이언트)가 고객센터 상담원(서버)1(첫번째 URL)에게 전화를 겁니다.

2. 상담원(서버)1(첫번째 URL)은 문의사항을 잘 이해하지 못하여 옆에있는 상담원(서버)2(두번째URL)에게 물어봤습니다.

3. 상담원(서버)1(첫번째 URL)은 상담원2에게 도움을 받아 사용자(클라이언트)에게 문의를 처리해줍니다.