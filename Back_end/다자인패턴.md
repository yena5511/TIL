## Singleton 패턴

- 프로세스에 특정 객체가 하나만 존재해야 할 때 쓰는 패턴
- 화면들에 공유되는 앱 세팅을 싱글턴으로 설정

- 자바에서 라이브러리나 프레임퉈크 없이 가장 안전하게 싱글톤을 생성할 수 있는 방법 중의 하나는 inner static class singleton이다

```java
package singleton.after;

public class Settings {

  private boolean darkMode = false;
  private int fontSize = 13;

  public boolean getDarkMode () { return darkMode; }
  public int getFontSize () { return fontSize; }

  public void setDarkMode (boolean _darkMode) { 
    darkMode = _darkMode; }
  public void setFontSize (int _fontSize) { 
    fontSize = _fontSize; }
}
```
- settings 란 클래스에서 다크모드 여부와 폰트 사이즈를 설정허고 접근 

```java
package singleton.after;

public class FirstPage {
  private Settings settings = Settings.getSettings();

  public void setAndPrintSettings () {
    settings.setDarkMode(true);
    settings.setFontSize(15);
    System.out.println(settings.getDarkMode() + " " + settings.getFontSize());
  }
}
```

```java
package singleton.after;

public class SecondPage {
  private Settings settings = Settings.getSettings();

  public void printSettings () {
    System.out.println(settings.getDarkMode() + " " + settings.getFontSize());
  }
}
```
- 페이지마다 다른 클래스를 만든다
- firstPage에서 settings 겍체의 설정들을 변경하고 그 내용을 출력
- secondPage에도 setting을 출력하는 함수를 만들고 메인에서 차례로 실행<br>
-> firstPage에서 변경한 내용들이 secondPage에는 적용되지 않음

*settings 클래스 변경*
```java
package singleton.after;

public class Settings {

  private Settings () {};
  private static Settings settings = null;

  public static Settings getSettings () {
    if (settings == null) {
      settings = new Settings();
    }
    return settings;
  }

  private boolean darkMode = false;
  private int fontSize = 13;

  public boolean getDarkMode () { return darkMode; }
  public int getFontSize () { return fontSize; }

  public void setDarkMode (boolean _darkMode) { 
    darkMode = _darkMode; }
  public void setFontSize (int _fontSize) { 
    fontSize = _fontSize; }
}
```

- static이 아닌 변수나 메소드들은 객체가 생성될 때마다 메모리의 공간을 새로 처지
- static으로 선언될 것들은 객체가 얼마나 만들어지든 메모리에 지정된 공간을 딱 하나씩만 존재

- 이 방법을 사용하면 멀티쓰레드에 안전하고, Lazy loading을 지원하며, serialization에도 안전한 싱글톤을 만들 수 있다

## Strategy 패턴

- 선택된 모두에 따라서, 검색 버튼을 눌렀을 때 실행되는 검색의 방식이 결정되도록 하는 코드
- 전략 패턴은 모드마다의 동작 하나하나를 모듈로 따로 분리해서, 버튼을 누를때마다 실행될 검색 모듈을 갈아끼워주는 방식의 코드

- 인터페이스는 그 자체로 객체를 만들 수 없지만 특정 인터페이스를 implement 한 클래스는 해당 인터페이스에서 지정한 메소드를 필수적으로 선언하고 장착해야 됨

```java
package strategy.after;

interface SearchStrategy {
  public void search ();
}

class SearchStratagyAll implements SearchStrategy {
  public void search () {
      System.out.println("SEARCH ALL");
      // 전체검색하는 코드
  }
}

class SearchStratagyImage implements SearchStrategy {
  public void search () {
      System.out.println("SEARCH IMAGE");
      // 이미지검색하는 코드
  }
}

class SearchStratagyNews implements SearchStrategy {
  public void search () {
      System.out.println("SEARCH NEWS");
      // 뉴스검색하는 코드
  }
}

class SearchStratagyMap implements SearchStrategy {
  public void search () {
      System.out.println("SEARCH MAP");
      // 지도검색하는 코드
  }
}
```

```java
package strategy.after;

public class SearchButton {

  private MyProgram myProgram;

  public SearchButton (MyProgram _myProgram) {
    myProgram = _myProgram;
  }

  private SearchStrategy searchStrategy = new SearchStratagyAll();
  
  public void setSearchStrategy (SearchStrategy _searchStrategy) {
    searchStrategy = _searchStrategy;
  }

  public void onClick () {
    searchStrategy.search();
  }
}
```
- search란 메소드를 갖기 때문에 SearchStrategy를 implement한 클래스들릉 모두 search라는 메소드르 갖고 있음

- 옵션들마다의 행동들을 모듈화해서 독립적이고 상호 교체 가능하게 만드는 것이 전력 패텬

## State 패턴

- 전략 패턴과 비슷 
- 전략 패턴은 어떤 동일한 틀 안에 있는 특정 적업의 방식, 모드를 바꿔줄 때
- state 패턴은 특정 상태마다 다르게 할 일을 나아가서 그 상태들 자체를 그 상태마다 실행시 할 일과 함께 하나하나 모듈화해서 지정해둘 때 쓰임

- 앱 화면의 다크모드 여부를 켰다 꼈다 하는 스위치를 프로그래밍한 예제

```java
package state;

public interface ModeState {
  public void toggle (ModeSwitch modeSwitch);
}

class ModeStateLight implements ModeState {
  public void toggle (ModeSwitch modeSwitch) {
    System.out.println("FROM LIGHT TO DARK");
    // 화면을 어둡게 하는 코드
    // ..
    // ..
    modeSwitch.setState(new ModeStateDark());
  }
}

class ModeStateDark implements ModeState {
  public void toggle (ModeSwitch modeSwitch) {
    System.out.println("FROM DARK TO LIGHT");
    // 화면을 밝게 하는 코드
    // ..
    // ..
    modeSwitch.setState(new ModeStateLight());

  }
}
```

```java
package state;

public interface ModeState {
  public void toggle (ModeSwitch modeSwitch);
}

class ModeStateLight implements ModeState {
  public void toggle (ModeSwitch modeSwitch) {
    System.out.println("FROM LIGHT TO DARK");
    // 화면을 어둡게 하는 코드
    // ..
    // ..
    modeSwitch.setState(new ModeStateDark());
  }
}

class ModeStateDark implements ModeState {
  public void toggle (ModeSwitch modeSwitch) {
    System.out.println("FROM DARK TO LIGHT");
    // 화면을 밝게 하는 코드
    // ..
    // ..
    modeSwitch.setState(new ModeStateLight());

  }
}
```
- 모드의 상태를 나타내는 인터페이스 
- 라이트 모드에서 스위치를 가동하면 다크모드로 다크모드에서는 라이크 모드로 상태가 전환

- State 패턴은 그 메소드가 실행될 때
모드도 전환되도록 하는 것

## Command 패턴

- 전략 패턴은 같은 일을 하되 그 알고리즘이나 방식이 갈아끼워지는 것
- command 패턴은 그 하는 일 자체가 다른것

- 출발 버튼을 누르면 차례차례 수행하는 학습용 장난감 코드

```java
package command;

public class Robot {
  public enum Direction { LEFT, RIGHT }

  public void moveForward (int space) {
    System.out.println(space + " 칸 전진");
  }

  public void turn (Direction _direction) {
    System.out.println(
      (_direction == Direction.LEFT ? "왼쪽" : "오른쪽") + "으로 방향전환"
    );
  }

  public void pickup () {
    System.out.println("앞의 물건 집어들기");
  }
}
```
- 메소드로 로봇이 할 수 있는 일들 
- 주어진 칸 숫자만큼 전진하기, 주어진 좌우 반향대로 회전하기, 앞의 물건을 집어올리기

```java
package command;

abstract class Command {
  protected Robot robot;

  public void setRobot (Robot _robot) {
    this.robot = _robot;
  }
  public abstract void execute ();
}

class MoveForwardCommand extends Command {
  int space;
  public MoveForwardCommand (int _space) { 
    space = _space; 
  }
  public void execute () {
    robot.moveForward(space);
  }
}

class TurnCommand extends Command {
  Robot.Direction direction;
  public TurnCommand (Robot.Direction _direction) {
    direction = _direction;
  }
  public void execute () {
    robot.turn(direction);
  }
}

class PickupCommand extends Command {
  public void execute () {
    robot.pickup();
  }
}
```
- execute는 추상 메서드라 인터페이스의 메소드처럼 부모 클래스가 아닌 자식 클래스에서 구현

- MoveForWardCommand는 칸 수를 의미하는 정수 값 space를 인자로 받아서 생성
- TurnCommand 클래스는 방향값과 함께 생성돼서 robot에게 해당 방행대로 전환하는 일을 시킴
- PickupCommand는 필요로 하는 변수 없이 robot이 앞의 물건을 집어올리도록 함

```java
package command;

import java.util.ArrayList;

public class RobotKit {
  private Robot robot = new Robot();
  private ArrayList<Command> commands = new ArrayList<Command>();

  public void addCommand (Command command) {
    commands.add(command);
  }
  public void start () {
    for (Command command : commands) {
      command.setRobot(robot);
      command.execute();
    }
  }
}
```
- Command를 상속한 클래스의 객체들을 담을 ArrayList인 commands

## Adapter

- 형식이 다른 둘 사이에 연결돼서 이 둘이 호환될 수 있도록 해주는 도구
-  인터페이스가 서로 다른 객체들이 같은 형식 아래 작동할 수 있도록 하는 역할

## Proxy
- 인터넷에서 받아와야 해서 시간이 걸리거나 메모리를 많이 차지하거나 하는 등의 이유로 객체로 여럿 생성하기가 부담이 괴는 것들이 있음
- Proxy 대리인 역할

## Facade

- 여러 클래스의 객체들을 복합적으로 사용해야 수행할 수 있는 작업들

```java
import java.util.Map;

public class FacadePattern {
  public static void main(String[] args) {

    double[] myGeoLoc = new GeoLocation().getGeoLoc();

    InternetConnection conn = new InternetConnection();
    conn.connect();
    String data = conn.getData("https://주소_API_URL", myGeoLoc);
    conn.disconnect();

    Map<String, Object> address = new Json().parse(data);

    System.out.println(address.get("address"));
    // 서울시 개발구 객체동

    new MyLocFacade().printMyAddress();
  }
}
```
```java
import java.util.HashMap;
import java.util.Map;

public class Json {
  public Map<String, Object> parse(String str) {
    Map<String, Object> result = new HashMap<>();
    result.put("address", "서울시 개발구 객체동");
    return result;
  }
}
```
- 내가 있는 곳의 주소를 출력하기 위해서는 GeoLocation 객체로 현 위치의 좌표를 얻고 -><br>
InternetConnection 객체로 인터넷에연결해서 -><br>
위치 정보를 JSON 형태의 문자열로 받아온 다음-> <br>
 인터넷 연결은 종료해주고, 받아온 문자열은 JSON클래스로 데이터형 객체로 바꿔서=><br>
이걸 인자로 주소를 담을 MAp 겍체를 생성하고 -> <br>
도로면 또는 지번 주소를 출력한다고 가정한다

- 작업이 여러곳에서 이루어져야 한다면 이것들을 하나의 메소드로 만들고 그겋 돌리는 클래스를 하나 만들어서 코드 한 줄로 실행
- 클래스의 생성자나, 내부의 변수들에 값이 들어가는 방식은 정해진 게 없으니까 필요따라 맞게 프로그래밍
- 작업을 실행하는 사용자 측에서 복잡한 연결관계를 알 필요가 없도록 구현부는 프랑스어로 '외벽'을 뜻하는 facade 뒤에 숨겨둔다

## Template method 패턴

- 전체 절차는 정해져 있지만 세부 절차는 자식 클래스로 다양화할 수 있는 패턴

- 다양화 된 방식을 각각 자식 클래스들에서 오버라이딩하는 방식으로 구현

- 템플릿 메소드에서의 상속은 일정 형식이 있다

- 부모 클래스에 전반 과정을 수행하는 메인 메소드가 있고 그 과정 가운데 세부 메소드가 있음
- 메인 메소드를 호출하면 실행 중에 이 세부 메소드들이 호출되는 형태
- 자식 과정에서는 그 세부 메소드를 오버라이딩하는 것

```java
public abstract class MapView {

  protected abstract void connectMapServer();
  protected abstract void showMapOnScreen();
  protected abstract void moveToCurrentLocation();

  public void initMap () {
    connectMapServer();
    showMapOnScreen();
    moveToCurrentLocation();
  }
}
```
- 해당 서버에 접속해서 받아온 지도를 화면에 보여주고 지도에서 현재 위치로 이동하는 코드 

``` java
public class NaverMapView extends MapView {

  @Override
  protected void connectMapServer() {
    System.out.println("네이버 지도 서버에 연결");
  };
  @Override
  protected void showMapOnScreen() {
    System.out.println("네이버 지도를 보여줌");
  };
  @Override
  protected void moveToCurrentLocation() {
    System.out.println("네이버 지도에서 현 좌표로 이동");
  };  
}
```

```java
public class KakaoMapView extends MapView {

  @Override
  protected void connectMapServer() {
    System.out.println("카카오 지도 서버에 연결");
  };
  @Override
  protected void showMapOnScreen() {
    System.out.println("카카오 지도를 보여줌");
  };
  @Override
  protected void moveToCurrentLocation() {
    System.out.println("카카오 지도에서 현 좌표로 이동");
  };
}
```
- 추상 세부 메소드들을 각각 구체화해서 네이버와 카카오의 방식대로 기능들을 구현

```java
public class TemplateExample {
  public static void main(String[] args) {
    new NaverMapView().initMap();
    new KakaoMapView().initMap();
  }
}
```
- 완성된 클래스를 객체로 생성해 메인 메소드에서 실행

- 템플랫 메소드는 어떤 일을 수행하는 몇가지 방법이 있는데 그 전반적 과정에 공통된 절차가 있을 때 코드를 효율적으로 짜기 위해 만들어진 패턴

## Decorator 패턴

- 캑체를 다른 객체에 넣어 기능을 추가하는 방식
- 특정 클래스의 객체들이 할 수 있는 일을 여러가지 두고 각 객체마다 사용자가 원하는대로 골라 시키거나 가능들을 필요에 따라 장착할 수 있도록 할 때 사용

```java
public interface Fighter {
  public void attack ();
}
```
- 공격 버튼을 누르면 실행되는 attack 메소드

```java
public class XWingFighter implements Fighter {
  @Override
  public void attack () {
    System.out.println("탄환 발사");
  }
}
```
- 인터페이스를 적용한 XWIng 전투기는 attack을 호출하면 기본적으로 탄환을 발사

```java
public abstract class FighterDecorator implements Fighter {

  private Fighter decoratedFighter;
  public FighterDecorator(Fighter _decoratedFighter) {
    decoratedFighter = _decoratedFighter;
  }

  @Override
  public void attack () {
    decoratedFighter.attack();
  }
}
```
- 변수로 Fighter 객체가 들어있고 이를 생성자로 받아서 지정

```java
public class LaserDecorator extends FighterDecorator {
  public LaserDecorator (Fighter _decoratedFighter) {
    super(_decoratedFighter);
  }
  @Override
  public void attack () {
    super.attack();
    System.out.println("레이저 발사");
  }
}
```
```java
public class LaserDecorator extends FighterDecorator {
  public LaserDecorator (Fighter _decoratedFighter) {
    super(_decoratedFighter);
  }
  @Override
  public void attack () {
    super.attack();
    System.out.println("레이저 발사");
  }
}
```
```java
public class PlasmaDecorator extends FighterDecorator {
  public PlasmaDecorator (Fighter _decoratedFighter) {
    super(_decoratedFighter);
  }
  @Override
  public void attack () {
    super.attack();
    System.out.println("플라즈마 발사");
  }
}
```
- 추상 클래스를 상속받은 3클래스
- Overridie된 메소드에서 super의 메소드를 실행한다는 건 상속해준 부모가 해당 메소드에서 하는 것을 그대로 실행한다는 의미

- 객체가 생성자 변수로 다른 객체 안에 들어감으로써 그 실행하는 메소드의 행동이 추가되도록 하는 것

## Factory-method 패턴

```java
abstract class Component {
  protected abstract String getCompName ();
  public Component () {
    System.out.println(this.getCompName() + " 생성");
  }
}

class Button extends Component {
  @Override
  protected String getCompName() { return "버튼"; }
}
class Switch extends Component {
  @Override
  protected String getCompName() { return "스위치"; }
}
class Dropdown extends Component {
  @Override
  protected String getCompName() { return "드랍다운"; }
}
```
- Component란 추상 클래스를 상속하는 Button, Switch, Dropdown 클래스들  

```java
class Console {

  private CompFactory compFactory = new CompFactory();

  Component comp1;
  Component comp2;
  Component comp3;

  void withoutFactory () {
    comp1 = new Button();
    comp2 = new Switch();
    comp3 = new Dropdown();
  }

  void withFactory () {
    comp1 = compFactory.getComp(Usage.PRESS);
    comp2 = compFactory.getComp(Usage.TOGGLE);
    comp3 = compFactory.getComp(Usage.EXPAND);
  }
}

enum Usage {
  PRESS, TOGGLE, EXPAND
}
```
- console 클래스에서 세 변수들에 Component란 추상 클래스를 상속하는 클래스들 중 하나씩 선택해서 값을 넣음

- 객체를 생성하는 코드들이 많으면 많을수록 객체 생성자를 변경하거나, 사용되는 객체 자체를 변경하는데 있어 부담이 커짐<br>
->  이 역할을 대신하는 클래스가 있다면 메소드 내부만 변경시키면 됨 

- 특정 종류의 기능들에 사용될 수 있는 클래스들의 종류가 많고 복잡할 때 이들을 사용하는 개발자 측에서는 이들을 다 알 필요 없이 사용할 객체의 조건들만 인다로 넘겨주면 이에 적절항 클래스를 찾아 객체로 생성해 넘겨주는 일은 팩토리가 알아서 처리

## Abstract-factory-method 패턴

- factory 패턴에 한 단계 더 추상화

```java
abstract class Component {
  protected abstract String getCompName ();
  public Component () {
    System.out.println(this.getCompName() + " 생성");
  }
}

class LightButton extends Component {
  @Override
  protected String getCompName() { return "라이트 버튼"; }
}
class DarkButton extends Component {
  @Override
  protected String getCompName() { return "다크 버튼"; }
}

class LightSwitch extends Component {
  @Override
  protected String getCompName() { return "라이트 스위치"; }
}
class DarkSwitch extends Component {
  @Override
  protected String getCompName() { return "다크 스위치"; }
}

class LightDropdown extends Component {
  @Override
  protected String getCompName() { return "라이트 드랍다운"; }
}
class DarkDropdown extends Component {
  @Override
  protected String getCompName() { return "다크 드랍다운"; }
}
```
- 버튼, 스위치, 드랍다운 요소들이 케마에 따라 여러 종류

```java
interface CompFactory {
  public Component getComp (Usage usage);
}

// 라이트 테마 공장
class LightCompFactory implements CompFactory {

  @Override
  public Component getComp (Usage usage) {
    if (usage == Usage.PRESS) {
      return new LightButton();
    } else if (usage == Usage.TOGGLE) {
      return new LightSwitch();
    } else {
      return new LightDropdown();
    }
  }
}

// 다크 테마 공장
class DarkCompFactory implements CompFactory {

  @Override
  public Component getComp (Usage usage) {
    if (usage == Usage.PRESS) {
      return new DarkButton();
    } else if (usage == Usage.TOGGLE) {
      return new DarkSwitch();
    } else {
      return new DarkDropdown();
    }
  }
}
```
- 기본 팩토리를 추상 클래스나 인터페이스로 하나 만들고 이를 상속한 테마마다의 팩토리를 둬서 처음부터 어떤 팩토리를 세우느냐에 따라 찍혀나오는 요소들의 테마기 달라지도록 할 수 있음

## Mediator 패턴

- 어떤 클래스의 객체에서 특정 이벤트가 발생할 때마다 연결된 다른 클래스들에 알려야 하는 경우
- 미디에디터 패턴은 특정 이벤트에 반응해서 관련된 다른 클래스들에 알려주는 일을 mediator, 중재자 역할을 하는 클래스에 전담시키는 것

## Composite 패턴

- 특정 클래스의 객체들을 트리 관계로 다루고
포함하는 객체와 포함되는 객체를 같은 인터페이스로
다룰 수 있도록 하는 패턴
- 포함하는 것들과 포함되는 것들이 같은 방식으로 다뤄질 수 있도록 할 떄 사용

```java
import java.util.ArrayList;

public interface FileSystem {
  public int getSize();
  public void remove();
}

class File implements FileSystem {
  private String name;
  private int size;

  public File (String _name, int _size) {
    name = _name; size = _size;
  }

  @Override
  public int getSize() {
    System.out.println(name + "파일 크기 : " + size);
    return size;
  }

  @Override
  public void remove() {
    System.out.println(name + " 파일 삭제");
  }

}

class Folder implements FileSystem {
  private String name;
  private ArrayList<FileSystem> includeds = new ArrayList<>();

  public Folder (String _name) {
    name = _name;
  }

  public void add(FileSystem fileSystem) {
    includeds.add(fileSystem);
  }

  @Override
  public int getSize() {
    int total = 0;
    for (FileSystem included : includeds) {
      total += included.getSize();
    }
    System.out.println(name + "폴더 크기 : " + total);
    System.out.println("- - - - -");
    return total;
  }

  @Override
  public void remove() {
    for (FileSystem included : includeds) {
      included.remove();
    }
    System.out.println(name + " 폴더 삭제");
    System.out.println("- - - - -");
  }
}
```
- 폴더와 파일 모두가 implement할 FileStstem이란 인터페이스

- 용량을 반환하는 메소드와 스스로를 삭제하는 메소드를 지장 


```java
public class CompositePattern {
  public static void main(String[] args) {
    Folder schoolFolder = new Folder("학교");

    Folder grade1Folder = new Folder("1학년");
    Folder grade2Folder = new Folder("2학년");

    schoolFolder.add(grade1Folder);
    schoolFolder.add(grade2Folder);

    File enterPhoto = new File("입학사진", 256);
    grade1Folder.add(enterPhoto);

    Folder sem1Folder = new Folder("1학기");
    Folder sem2Folder = new Folder("2학기");

    grade2Folder.add(sem1Folder);
    grade2Folder.add(sem2Folder);

    File lecturePlan = new File("강의계획서", 120);
    sem1Folder.add(lecturePlan);

    Folder projFolder = new Folder("프로젝트");
    sem2Folder.add(projFolder);

    File draft = new File("드래프트", 488);
    File finalResult = new File("결과물", 560);

    projFolder.add(draft);
    projFolder.add(finalResult);

    schoolFolder.getSize();
    // 입학사진파일 크기 : 256
    // 1학년폴더 크기 : 256
    // - - - - -
    // 강의계획서파일 크기 : 120
    // 1학기폴더 크기 : 120
    // - - - - -
    // 드래프트파일 크기 : 488
    // 결과물파일 크기 : 560
    // 프로젝트폴더 크기 : 1048
    // - - - - -
    // 2학기폴더 크기 : 1048
    // - - - - -
    // 2학년폴더 크기 : 1168
    // - - - - -
    // 학교폴더 크기 : 1424
    // - - - - -

    schoolFolder.remove();
    // 입학사진 파일 삭제
    // 1학년 폴더 삭제
    // - - - - -
    // 강의계획서 파일 삭제
    // 1학기 폴더 삭제
    // - - - - -
    // 드래프트 파일 삭제
    // 결과물 파일 삭제
    // 프로젝트 폴더 삭제
    // - - - - -
    // 2학기 폴더 삭제
    // - - - - -
    // 2학년 폴더 삭제
    // - - - - -
    // 학교 폴더 삭제
    // - - - - -
  }
}
```

